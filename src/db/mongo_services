# Import required modules
from typing import List, Optional
from bson import ObjectId
from datetime import datetime
from app.core.database import db
from app.models.data_schema import Conversation, MessageContent, User
from fastapi import HTTPException
from pymongo.errors import DuplicateKeyError
from pymongo import ASCENDING
from app.core.logging_config import setup_logging
import base64
import hashlib

# Initialize logger
logger = setup_logging(__name__)

class MongoService:
    def __init__(self):
        self._database = db.db
        self._indexes_ensured = False
        logger.debug("MongoService initialized")

    async def ensure_indexes(self):
        """Ensure database indexes are created"""
        if self._indexes_ensured:
            return
        await self._ensure_index()
        self._indexes_ensured = True
        logger.debug("Database indexes ensured")

    async def _ensure_index(self):
        """Create optimized indexes for collections"""
        collections = {
            "users": [
                ("email", ASCENDING, True),
                ("conversations._id", ASCENDING)
            ],
            "conversations": [
                ("user_id", ASCENDING),
                ("is_deleted", ASCENDING),
                ("last_modified", -1)
            ],
            "messages": [
                ("conversation_id", ASCENDING),
                ("timestamp", -1)
            ],
            "retrieved_files": [
                ("file_id", ASCENDING, True),
                ("created_at", -1),
                ("title_hash", ASCENDING, True)
            ]
        }
        
        for collection, indexes in collections.items():
            try:
                existing_indexes = await self._database[collection].index_information()
                for idx in indexes:
                    index_name = f"{idx[0]}_1"
                    if index_name not in existing_indexes:
                        await self._database[collection].create_index(
                            [(idx[0], idx[1])],
                            unique=idx[2] if len(idx) > 2 else False,
                            background=True
                        )
                        logger.debug(f"Created index {index_name} on collection {collection}")
            except Exception as e:
                logger.error(f"Error ensuring index on {collection}: {str(e)}")

    @property
    def conversation_collection(self):
        return self._database.conversations

    @property
    def message_collection(self):
        return self._database.messages

    @property
    def user_collection(self):
        return self._database.users

    @property
    def retrieved_files_collection(self):
        return self._database.retrieved_files

    async def create_conversation(self, user_id: str, title: str, filter_dict: dict = {}) -> Conversation:
        """Create a new conversation for a user"""
        logger.debug(f"Creating conversation for user {user_id} with title {title}")
        user = await self.user_collection.find_one({"_id": ObjectId(user_id)})
        if not user:
            logger.error(f"User {user_id} not found")
            raise HTTPException(status_code=404, detail="User not found")
        
        now = datetime.utcnow()
        conversation = Conversation(
            title=title,
            start_time=now,
            last_modified=now,
            messages=[],
            filter=filter_dict,
            user_id=ObjectId(user_id)
        )
        
        conv_dict = conversation.model_dump(by_alias=True, exclude={'id'})
        result = await self.conversation_collection.insert_one(conv_dict)
        conversation.id = result.inserted_id

        await self.user_collection.update_one(
            {"_id": ObjectId(user_id)},
            {"$push": {"conversations": {"_id": result.inserted_id}}}
        )
        
        logger.info(f"Created conversation {result.inserted_id} for user {user_id}")
        return conversation

    async def get_conversations(self, user_id: str) -> List[Conversation]:
        """Get all conversations for a user"""
        try:
            logger.debug(f"Retrieving conversations for user {user_id}")
            pipeline = [
                {"$match": {"_id": ObjectId(user_id)}},
                {"$lookup": {
                    "from": "conversations",
                    "localField": "conversations._id",
                    "foreignField": "_id",
                    "as": "full_conversations"
                }},
                {"$unwind": "$full_conversations"},
                {"$match": {"full_conversations.is_deleted": False}},
                {"$sort": {"full_conversations.last_modified": -1}},
                {"$replaceRoot": {"newRoot": "$full_conversations"}}
            ]
            
            cursor = self.user_collection.aggregate(pipeline)
            conversations = await cursor.to_list(length=None)
            logger.info(f"Retrieved {len(conversations)} conversations for user {user_id}")
            return [Conversation(**conv) for conv in conversations]
            
        except Exception as e:
            logger.error(f"Error getting conversations for user {user_id}: {str(e)}")
            return []

    async def get_conversation(self, conversation_id: str, user_id: str) -> Optional[Conversation]:
        """Get a specific conversation by ID"""
        try:
            logger.debug(f"Retrieving conversation {conversation_id} for user {user_id}")
            user = await self.user_collection.find_one({
                "_id": ObjectId(user_id),
                "conversations._id": ObjectId(conversation_id)
            })
            
            if not user:
                logger.warning(f"User {user_id} not found or does not have access to conversation {conversation_id}")
                return None
            
            conversation = await self.conversation_collection.find_one({
                "_id": ObjectId(conversation_id),
                "is_deleted": False
            })
            
            if conversation:
                logger.info(f"Retrieved conversation {conversation_id}")
            else:
                logger.warning(f"Conversation {conversation_id} not found")
                
            return Conversation(**conversation) if conversation else None
            
        except Exception as e:
            logger.error(f"Error retrieving conversation {conversation_id}: {str(e)}")
            return None

    async def add_message(self, user_id: str, conversation_id: str, message: MessageContent) -> MessageContent:
        """Add a message to a conversation"""
        logger.debug(f"Adding message to conversation {conversation_id} for user {user_id}")
        if not await self.get_conversation(conversation_id, user_id):
            logger.error(f"Conversation {conversation_id} not found or access denied for user {user_id}")
            raise HTTPException(status_code=404, detail="Conversation not found or access denied")
        
        message_dict = message.model_dump(by_alias=True)
        message_dict.update({
            "timestamp": datetime.utcnow(),
            "user_id": ObjectId(user_id),
            "conversation_id": ObjectId(conversation_id),
            "is_good_response": None,
            "feedback": None
        })
        
        result = await self.message_collection.insert_one(message_dict)
        message.id = result.inserted_id
        
        message_doc = {
            "_id": result.inserted_id,
            "role": message.role,
            "content": message.content,
            "timestamp": message_dict["timestamp"],
            "is_good_response": message_dict["is_good_response"],
            "user_id": message_dict["user_id"],
            "conversation_id": message_dict["conversation_id"],
            "feedback": message_dict["feedback"]
        }
        
        if message.retrieved_docs:
            message_doc["retrieved_docs"] = [doc.model_dump() for doc in message.retrieved_docs]
        
        update_result = await self.conversation_collection.update_one(
            {"_id": ObjectId(conversation_id)},
            {
                "$push": {"messages": message_doc},
                "$set": {"last_modified": datetime.utcnow()}
            }
        )
        
        if update_result.modified_count == 0:
            logger.error(f"Failed to update conversation {conversation_id} with new message")
            await self.message_collection.delete_one({"_id": result.inserted_id})
            raise HTTPException(status_code=500, detail="Failed to update conversation")
        
        logger.info(f"Successfully added message to conversation {conversation_id}")
        return 200

    async def update_message_feedback(
        self,
        conversation_id: str,
        message_id: str,
        is_good_response: Optional[bool] = None,
        feedback: Optional[str] = None
    ) -> bool:
        """Update feedback for a message"""
        try:
            logger.debug(f"Updating feedback for message {message_id} in conversation {conversation_id}")
            update_fields = {}
            if is_good_response is not None:
                update_fields["is_good_response"] = is_good_response
            if feedback is not None:
                update_fields["feedback"] = feedback
                
            if not update_fields:
                logger.warning("No feedback fields to update")
                return False
            # conversation 
            # conversation = await self.conversation_collection.find_one({"_id": ObjectId(conversation_id)})
            # logger.debug(f"conversation: {conversation}")
            # # find message with message_id
            # message = await self.message_collection.find_one({"_id": ObjectId(message_id)})
            # logger.debug(f"message: {message}")
                
            message_result = await self.message_collection.update_one(
                {"_id": ObjectId(message_id), "conversation_id": ObjectId(conversation_id)},
                {"$set": update_fields}
            )

            conversation_result = await self.conversation_collection.update_one(
                {"_id": ObjectId(conversation_id), "messages._id": ObjectId(message_id)},
                {"$set": {f"messages.$[elem].{key}": value for key, value in update_fields.items()}},
                array_filters=[{"elem._id": ObjectId(message_id)}]
            )
            
            # conversation_result = await self.conversation_collection.find_one({"_id": ObjectId(conversation_id)})
            # logger.debug(f"conversation_result: {conversation_result}")

            # message_result = await self.message_collection.find_one({"_id": ObjectId(message_id)})
            # logger.debug(f"message_result: {message_result}")

            success = message_result and conversation_result
            if success:
                logger.info(f"Successfully updated feedback for message {message_id}")
                logger.debug(f"message_result: {message_result}")
                logger.debug(f"conversation_result: {conversation_result}")
            else:
                logger.warning(f"Failed to update feedback for message {message_id}")
            return success
            
        except Exception as e:
            logger.error(f"Error updating message feedback: {str(e)}")
            return False

    async def delete_conversation(self, conversation_id: str, user_id: str) -> bool:
        """Soft delete a conversation"""
        try:
            logger.debug(f"Attempting to delete conversation {conversation_id} for user {user_id}")
            user = await self.user_collection.find_one({
                "_id": ObjectId(user_id),
                "conversations._id": ObjectId(conversation_id)
            })
            
            if not user:
                logger.warning(f"User {user_id} not found or does not have access to conversation {conversation_id}")
                return False
            
            update_result = await self.conversation_collection.update_one(
                {"_id": ObjectId(conversation_id)},
                {"$set": {"is_deleted": True}}
            )
        
            
            success = update_result.modified_count > 0
            if success:
                logger.info(f"Successfully deleted conversation {conversation_id}")
                logger.debug(f"update_result: {update_result}")
            else:
                logger.warning(f"Failed to delete conversation {conversation_id}")
            return success
            
        except Exception as e:
            logger.error(f"Error deleting conversation: {str(e)}")
            return False

    async def create_user(self, email: str, full_name: str) -> User:
        """Create a new user"""
        logger.debug(f"Creating new user with email {email}")
        new_user = User(
            id=ObjectId(),
            email=email,
            full_name=full_name,
            conversations=[]
        )
        
        try:
            user_dict = new_user.model_dump(by_alias=True)
            result = await self.user_collection.insert_one(user_dict)
            new_user.id = result.inserted_id
            logger.info(f"Successfully created user with ID {result.inserted_id}")
            return new_user
        except DuplicateKeyError:
            logger.error(f"Failed to create user - email {email} already exists")
            raise HTTPException(status_code=400, detail="User ID already exists")

    async def get_user_by_email(self, email: str) -> Optional[User]:
        """Get a user by email"""
        logger.debug(f"Looking up user by email {email}")
        user = await self.user_collection.find_one({"email": email})
        if user:
            logger.info(f"Found user with email {email}")
        else:
            logger.warning(f"No user found with email {email}")
        return User(**user) if user else None

    async def save_retrieved_file(self, document_title: str, file_path: str):
        """Save retrieved file information and return file_id"""
        try:
            # Create hash of document title for uniqueness check
            title_hash = hashlib.md5(document_title.encode()).hexdigest()
            
            # Check if document with same title hash exists
            existing_doc = await self.retrieved_files_collection.find_one({
                "title_hash": title_hash
            })
            
            if existing_doc:
                logger.debug(f"Document with title '{document_title}' already exists, returning existing ID")
                return existing_doc
            
            # Insert new document if no duplicate found
            result = await self.retrieved_files_collection.insert_one({
                "file_path": file_path,
                "document_title": document_title,
                "title_hash": title_hash,
                "created_at": datetime.utcnow()
            })
            
            if result and result.inserted_id:
                logger.debug(f"Successfully saved retrieved file with ID: {result.inserted_id}")
                return result
            else:
                logger.error(f"Error saving retrieved file, no ID returned: {result}")
                return None
        except Exception as e:
            logger.error(f"Error saving retrieved file: {str(e)}")
            raise

    async def get_file_by_id(self, file_id: str):
        """Get file information by file_id"""
        return await self.retrieved_files_collection.find_one({"_id": ObjectId(file_id)})
